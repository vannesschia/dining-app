import pulp
from app.query import fetch_menu_items
from pprint import pprint

# 1. The "Virtual Menu" (Generated by your AI step)
offerings = fetch_menu_items(1, "lunch")
# pprint(offerings)

# maximize convenience score
# maximizing sum of (x_i * convenience_score_i)
# main constraints (defaults to get from external library):
# total calories 
# total protein
# total carbs
# total fats

for o in offerings:
    # Base Tier Score (The "Quality" Score)
    if o['type'] == 'entree' and o['convenience_score'] == 5:
        base_score = 1000
    elif o['type'] == 'entree' and o['convenience_score'] == 3:
        base_score = 500
    else:
        base_score = 1

    calorie_bonus = o['calories_kcal'] * 0.5 
    
    o['solver_score'] = base_score + calorie_bonus

prob = pulp.LpProblem("Meal_Optimizer", pulp.LpMaximize)

x = pulp.LpVariable.dicts("item", [o["id"] for o in offerings], lowBound=0, upBound=2, cat="Integer")
# for o in offerings:
#     if o['type'] == 'entree' and o['convenience_score'] == 5:
#         prob += x[o['id']] <= 2

# 4. Objective Function: Maximize Convenience
# This naturally tells the solver: "Pick the Halal Plate if possible, only pick loose eggs if you REALLY need the protein."
# prob += pulp.lpSum([x[o["id"]] * o["convenience_score"] for o in offerings])
prob += pulp.lpSum([x[o["id"]] * o["solver_score"] for o in offerings])

# 5. Constraints
# Must hit Calories
prob += pulp.lpSum([x[o["id"]] * o["calories_kcal"] for o in offerings]) >= 900
prob += pulp.lpSum([x[o["id"]] * o["calories_kcal"] for o in offerings]) <= 1200

# Must hit Protein
prob += pulp.lpSum([x[o["id"]] * o["protein_g"] for o in offerings]) >= 60
prob += pulp.lpSum([x[o["id"]] * o["total_carbohydrate_g"] for o in offerings]) <= 150
prob += pulp.lpSum([x[o["id"]] * o["total_fat_g"] for o in offerings]) <= 40
# Max Items on Tray
all_vars = [x[o['id']] for o in offerings]
# prob += pulp.lpSum(all_vars) <= 6  # Max 6 items on the tray total
entree_vars = [
    x[o['id']] 
    for o in offerings 
    if o.get('solver_score', 0) >= 500
]
prob += pulp.lpSum(entree_vars) <= 5
prob += pulp.lpSum(entree_vars) >= 1
for o in offerings:
    if o["type"] == "dessert":
        prob += x[o['id']] == 0
# prob += x[636] == 1
# LOGIC CONSTRAINT: "Don't eat the same thing twice"
# (If we pick the "Toast Combo", we cannot ALSO pick "Toast Eggs" separately)
# You can handle this by grouping ID prefixes in your code.
# prob += x["toast_eggs"] + x["toast_combo"] <= 1 

# ---------------------------------------------------------
# VARIETY SOLVER LOOP
# ---------------------------------------------------------
solutions_found = 0
desired_solutions = 25  # How many different menus do you want?

while solutions_found < desired_solutions:
    # 1. Solve
    status = prob.solve(pulp.PULP_CBC_CMD(msg=0))
    
    if status != 1:
        print(f"Stopped: No more feasible solutions found (Found {solutions_found}).")
        break
        
    solutions_found += 1
    print(f"\n=== OPTION #{solutions_found} ===")
    
    # Track the items in THIS specific solution to "ban" them later
    current_items = []
    
    # Print the Menu
    total_cal = 0
    total_pro = 0
    total_carb = 0
    total_fat = 0
    for o in offerings:
        qty = x[o['id']].varValue
        if qty and qty > 0:
            print(f"  - {int(qty)} x {o['name']} ({o['calories_kcal']} kcal)")
            total_cal += o['calories_kcal'] * qty
            total_pro += o['protein_g'] * qty
            total_carb += o['total_carbohydrate_g'] * qty
            total_fat += o['total_fat_g'] * qty
            
            # Record this item choice
            current_items.append(x[o['id']])

    print(f"  [Totals: {total_cal} kcal, {total_pro}g protein, {total_carb}g carbs, {total_fat}g fat]")

    # 2. ADD THE "BAN" CONSTRAINT (The "Integer Cut")
    # This says: "The sum of the items you just picked must be at least 1 less than before."
    # Effectively: "You cannot pick this exact combination of items again."
    # This forces the solver to change at least one item for the next loop.
    prob += pulp.lpSum(current_items) <= pulp.lpSum([v.varValue for v in current_items]) - 1